/**
 * AGENTS.md Manager
 *
 * Generates and maintains the AGENTS.md file for a project.
 * Contains tech stack, project structure, and agent-relevant context.
 */

import { existsSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";
import type { ProjectStack } from "./detector.js";

export class AgentsMdManager {
  private filePath: string;

  constructor(private projectRoot: string) {
    this.filePath = join(projectRoot, "AGENTS.md");
  }

  exists(): boolean {
    return existsSync(this.filePath);
  }

  read(): string {
    if (!this.exists()) return "";
    return readFileSync(this.filePath, "utf-8");
  }

  generate(stack: ProjectStack): string {
    const sections: string[] = [];

    sections.push(`# AGENTS.md - ${stack.projectName}\n`);
    sections.push(
      "> Auto-generated by WabiSabi CLI. Update as needed.\n",
    );

    // Tech Stack
    sections.push("## Tech Stack\n");
    sections.push(`- **Language:** ${stack.language.join(", ")}`);
    if (stack.framework.length > 0) {
      sections.push(`- **Framework:** ${stack.framework.join(", ")}`);
    }
    sections.push(`- **Package Manager:** ${stack.packageManager}`);
    if (stack.buildTool.length > 0) {
      sections.push(`- **Build Tool:** ${stack.buildTool.join(", ")}`);
    }
    if (stack.testFramework.length > 0) {
      sections.push(`- **Test Framework:** ${stack.testFramework.join(", ")}`);
    }
    if (stack.linter.length > 0) {
      sections.push(`- **Linter:** ${stack.linter.join(", ")}`);
    }
    sections.push(`- **VCS:** ${stack.vcs}`);

    // Config Files
    if (stack.configFiles.length > 0) {
      sections.push("\n## Config Files\n");
      for (const file of stack.configFiles) {
        sections.push(`- \`${file}\``);
      }
    }

    // Entry Points
    if (stack.entryPoints.length > 0) {
      sections.push("\n## Entry Points\n");
      for (const entry of stack.entryPoints) {
        sections.push(`- \`${entry}\``);
      }
    }

    // Environment Variables
    if (stack.envStructure.length > 0) {
      sections.push("\n## Environment Variables\n");
      for (const envVar of stack.envStructure) {
        sections.push(`- \`${envVar}\``);
      }
    }

    // Preferences (empty section for user customization)
    sections.push("\n## Preferences\n");
    sections.push(
      "<!-- Add project-specific preferences for agents here -->",
    );

    return sections.join("\n") + "\n";
  }

  write(stack: ProjectStack): void {
    const content = this.generate(stack);
    writeFileSync(this.filePath, content, "utf-8");
  }

  update(stack: ProjectStack): void {
    if (!this.exists()) {
      this.write(stack);
      return;
    }

    // If file exists, only update the Tech Stack section, preserve the rest
    const current = this.read();
    const techStackMarker = "## Tech Stack";
    const nextSectionRegex = /\n## (?!Tech Stack)/;

    const techIdx = current.indexOf(techStackMarker);
    if (techIdx === -1) {
      // No tech stack section, append it
      const newContent = this.generate(stack);
      writeFileSync(this.filePath, newContent, "utf-8");
      return;
    }

    const afterTech = current.slice(techIdx);
    const nextSection = afterTech.search(nextSectionRegex);

    if (nextSection === -1) return; // Only tech stack section, leave as is

    // Build new tech stack section
    const newStack = this.generate(stack);
    const newTechEnd = newStack.indexOf("\n## ", newStack.indexOf("## Tech Stack") + 1);
    const newTechSection =
      newTechEnd === -1
        ? newStack.slice(newStack.indexOf("## Tech Stack"))
        : newStack.slice(newStack.indexOf("## Tech Stack"), newTechEnd);

    const before = current.slice(0, techIdx);
    const after = current.slice(techIdx + nextSection);
    const updated = before + newTechSection + "\n" + after;

    writeFileSync(this.filePath, updated, "utf-8");
  }
}
